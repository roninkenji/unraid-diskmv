#!/bin/bash
# diskmv - Move an unRAID user share directory from one disk to another
#
# usage: diskmv directory srcdisk destdisk
#
# A find/rsync structure is used to copy files and directories and then 
# delete only if the copy succeed, similar to the unRAID mover script.

usage(){
cat << EOF

usage: diskmv directory srcdisk destdisk

All parameters are required

directory    Any directory that is contained in the user share file system.
             It can be specified as an absolute or relative path and can be 
             relative to the current directory or the /mnt/user/ directory.  

srcdisk      Source disk which can be any valid disk in the unraid array. 
             Examples: 'disk2', 'disk18' or 'cache'.

destdisk     Destination disk which can be any valid disk in the unraid array.
             Examples: 'disk2', 'disk18' or 'cache'.

Options:

-t	test mode, do not copy or delete files
-f	force, override test mode and take action
-k	keep source files, do not delete after successful copy
-l	link, copy symlinks as symlinks, default is to ignore symlinks
-c	clobber, duplicates on destination will be overwritten
-v	verbose, output more information
-q	quiet, output less information
-h	help, print this help message

EOF
}

[ ${DEBUG:=0} -gt 0 ] && set -x -v

doit='true'   # Default to take action instead of dry-run
keepsrc='false'   # Delete source files by default if copy works
symlinks='false'  # Default rsync to not copy symlinks as symlinks
clobber='false'   # Default to skip duplicates
verbose=1	# Default to output some but not all info

while :; do
  case "$1" in
    -h|-\?|--help)
      usage
      exit 0
      ;;
    -t|--test) # Specify test mode where no files are moved
      doit='false'
      ;;
    -f|--force) # Override test mode and force action
      doit='true'
      ;;
    -k|--keepsource) # Do not delete any source files
      keepsrc='true'
      ;;
    -l|--links) # Copy symlinks as symlinks
      symlinks='true'
      ;;
    -c|--clobber) # Clobber duplicates on destination
      clobber='true'
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity
      ;;
    -q|--quiet)
      verbose=$((verbose - 1)) # Each -q argument subtracts 1 from verbosity
      ;;
    --) # End of all options
      break
      ;;
    -?*)
      echo "Unknown option (ignored): $1" >&2
      ;;
    *) # Default case: if no more options then break out of loop
      break
  esac
  shift
done

if [ -d "$1" ]
then
  FULLNAME=$(readlink -e "$1")   # Handle relative path
  MERGEDIR="${FULLNAME#/mnt/*/}"   # Remove any /mnt/*/ prefix
else
  MERGEDIR="$1"
fi

if [ ! -d "/mnt/user/$MERGEDIR" ]
then 
  echo "'$1' is not a valid user share directory." >&2
  usage >&2
  exit 1
fi

if [ -z $2 -o -z $3 ]
then
  echo "Both source and destination disks must be specified."  >&2
  usage >&2
  exit 1
fi

SRCDISK="${2#/mnt/}"    #Remove any leading /mnt/ prefix
SRCDISK="${SRCDISK%%/*}"    #Remove any trailing path
if [[ ! -d "/mnt/$SRCDISK" \
     || "$SRCDISK" != disk[1-9] && "$SRCDISK" != disk[1-9][0-9] && "$SRCDISK" != "cache" \
   ]]
then
  echo "'$2' is not a valid disk." >&2
  usage >&2
  exit 1
fi

DESTDISK="${3#/mnt/}"    #Remove any leading /mnt/ prefix
DESTDISK="${DESTDISK%%/*}"    #Remove any trailing path
if [[ ! -d "/mnt/$DESTDISK" \
     || "$DESTDISK" != disk[1-9] && "$DESTDISK" != disk[1-9][0-9] && "$DESTDISK" != "cache" \
   ]]
then
  echo "'$3' is not a valid disk." >&2
  usage >&2
  exit 1
fi

RSYNCOPTS="-dIWRpEAXogtl --numeric-ids --inplace"
# rsync options used:
# -d, --dirs                  transfer directories without recursing
# -I, --ignore-times          don't skip files that match in size and mod-time
# -W, --whole-file            copy files whole (without delta-xfer algorithm)
# -R, --relative              use relative path names
# -p, --perms                 preserve permissions
# -E, --executability         preserve the file's executability
# -A, --acls                  preserve ACLs (implies --perms)
# -X, --xattrs                preserve extended attributes
# -o, --owner                 preserve owner (super-user only)
# -g, --group                 preserve group
# -t, --times                 preserve modification times
# -l, --links                 copy symlinks as symlinks
#     --numeric-ids           don't map uid/gid values by user/group name
#     --inplace               update destination files in-place

# rsync options set optionally below
# -i, --itemize-changes       output a change-summary for all updates

if [ $doit == 'true' ]; then
  if [ $keepsrc == 'false' ]; then
    DELCLAUSE="-delete"
  else
    DELCLAUSE=""
  fi
else
  echo "Running in test mode, no files will be moved."
  RSYNCOPTS="$RSYNCOPTS --dry-run"
  DELCLAUSE=""
fi

if [ $symlinks == 'true' ]; then
  SLCLAUSE="-o -type l"
else
  SLCLAUSE=""
fi

if [ $clobber == 'true' ]; then
  DUPCLAUSE=""
else
  # This duplicate clause as annoyingly complicated:
  # If the specified file is a directory on the destination disk or if the 
  #   specified file does not exist on the destination disk, then the duplicate
  #   clause is finished and the next clause in the find statement is processed.
  # Otherwise, some output is printed and false is returned so the rest of the
  #   clauses in the find statement are not processed and the file is not
  #   copied or moved.
  DUPCLAUSE=" \
      ( \
        -exec [ -d /mnt/$DESTDISK/{} ] ; \
        -o \
        -exec [ ! -e /mnt/$DESTDISK/{} ] ; \
        -o \
        -exec echo Duplicate skipped: {} ; \
        -a \
        -exec false ; \
      ) "
fi

if [ $verbose -gt 0 ]; then
  PRINTCLAUSE="-print"
else
  PRINTCLAUSE=""
fi

if [ $verbose -gt 1 ]; then
  RSYNCOPTS="$RSYNCOPTS -i"
fi

echo "Merging /mnt/$SRCDISK/$MERGEDIR into /mnt/$DESTDISK/$MERGEDIR"
cd "/mnt/$SRCDISK"

find "./$MERGEDIR" -depth \
      \( \
        \( -type f ! -exec fuser -s {} \; \) \
        -o \
        \( -type d -empty \) \
        $SLCLAUSE \
      \) \
      $PRINTCLAUSE \
      $DUPCLAUSE \
      -exec rsync $RSYNCOPTS {} "/mnt/${DESTDISK}/" \; \
      $DELCLAUSE

echo "diskmv finished"
